---
title: Java 内存模型
date: 2018-04-17 22:00
tags:
	- java
---

## JMM

`Java Memory Model : Java 内存模型`

## 内存区分类

![](http://blog-1251826226.coscd.myqcloud.com/2654250-152293461531f520.png)

Java 虚拟机的内存一般划分为以上几个区域，其中，方法区、堆区是线程间共享的，虚拟机栈、本地方法栈、程序计数器则是每个线程独有的。

### 方法区

存放类信息、常量、静态变量、编译后的代码等。

### 堆区

相比较之下内存最大的区域，存放几乎所有对象实例，GC 操作的主要区域。

之所以在 Java 中不需要像 C++ 一样对每一个使用`new`创建的实例都要进行`delete`操作，主要原因就在于对这个区域的处理。一般情况下，直接使用定义语句`A a = new A()`的时候，变量 a 存储于虚拟机栈，但是这个类 A 的实例确实存放于 Java 堆的，a 只是一个引用，指向 A 的实例真正所在的地方。当 a 所在的方法执行完成之后，会有一个栈帧出栈操作，这是变量 a 就会被销毁，但是 A 的实例仍然是处于 Java 堆中的，正因如此，所以需要我们手动销毁这个实例。但是在 Java 虚拟机中，有一个垃圾回收机制，作用就是，对那些不需要再使用的实例、变量进行内存回收，作用到 Java 堆上，就可以自动批量化地将那些不再使用的`new`出来的实例释放掉，那么就会有几个问题，如何确定某个实例是否需要释放，如何释放实例，释放实例之后的后续处理工作。

#### 垃圾确定算法

如何确定一个实例已经不会被使用了，描述出来应该是外部不再存在对这个实例的引用，或者即使存在着引用，这个引用也是不可达的（从程序的根对象开始找不到到达这个对象的路径）。所以这就对应着两种方法，**引用计数法**和**标记-清除算法**。

##### 引用计数法

每个对象都对应着一个计数器，对象被创建的时候计数器置0，每当有一个新的引用引用了这个对象，计数器 +1 ，每当对象的引用被回收或者引用了另一个对象的时候，计数器 -1 。

```java
// 以下说明一个实例的计数器工作的过程
public void main() {
    A a = new A();	//创建实例并添加一个引用，计数器为 1
    A b = a;		// 增加实例引用，计数器为 2
    add(a);			// 方法执行完成，引用 c 回收，计数器为 2
    b = new B();	// b 引用了另一个实例，计数器为 1
}

public void add(A a) {
    A c = a;		// 增加实例引用，计数器为 3
}
```

但是这有一个问题，即有一个类 A ，它内部有一个对类 B 的实例的引用，而在类 B 内部也有一个对类 A 的实例的引用，构成一个环引用之后，即便是这两个类的实例都不再需要了，计数器也不会为 0 也就无法回收这两个实例，所以就有了另一种方法。

##### 标记-清除算法

将每一个实例看作是一个节点，那么实例与实例之间的引用关系看作两个节点之间的边，这样就构成了一个表示实例之间引用关系的图，然后在这个图的基础上，确定某一个或几个根节点，然后从根节点出发，找到所有根节点能到达的节点，然后为这个节点做一个可达的标记，那么遍历完成之后，那么没有被标记的节点肯定就是不可达的，然后进行回收。

能作为根节点的一般有：

1. 虚拟机栈中引用的对象
2. 方法区中静态属性的对象
3. 方法区中常量引用的对象
4. 本地方法栈中引用的对象（Native 对象）

#### 垃圾回收算法

现在一般使用的垃圾回收算法为 Generation 算法，将一片内存区域分成不同的 generation ，即分为 年轻代、年老代、持久代，然后针对不同的 generation 有不同的处理。

### 虚拟机栈

生命周期与线程相同，每个 Java 方法执行的时候都会在栈顶创建一个栈帧，方法执行完成这个栈帧就会出栈。

### 栈帧

栈帧是 Java 方法执行的支持数据，为每一个方法保存一系列的信息，如方法内的局部变量、方法执行后的返回地址等。

1. 局部变量表
2. 操作栈
3. 动态连接
4. 方法返回地址
5. 额外附加信息

### 本地方法栈

为 Native 方法提供内存空间，与虚拟机栈类似。

### 程序计数器

当前线程所执行的字节码行号指示器，内存较小。

如果当前线程在执行 Java 方法，计数器记录当前正在执行的字节码的地址，如果在执行 Native 方法，则为空。